{"version":3,"sources":["webpack:///bulbs-cinemagraph.js","webpack:///./elements/bulbs-cinemagraph/bulbs-cinemagraph.js","webpack:///./~/iphone-inline-video/dist/iphone-inline-video.common-js.js","webpack:///./~/poor-mans-symbol/dist/poor-mans-symbol.common-js.js"],"names":["webpackJsonp","0","module","exports","__webpack_require__","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","call","_defaults","defaults","keys","getOwnPropertyNames","i","length","value","getOwnPropertyDescriptor","configurable","undefined","defineProperty","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","enumerable","writable","setPrototypeOf","BulbsHTMLVideoElement","_register","_util","_iphoneInlineVideo","iphoneInlineVideo","HTMLVideoElement","BulbsCinemagraph","_BulbsHTMLVideoElemen","this","apply","arguments","createdCallback","_this2","hasAttribute","console","warn","get","parseFloat","getAttribute","setAttribute","addEventListener","play","pause","attachedCallback","InViewMonitor","add","detachedCallback","remove","registerElement","197","_interopDefault","ex","Intervalometer","cb","loop","now","rafId","requestAnimationFrame","previousLoopTime","start","stop","cancelAnimationFrame","preventEvent","element","eventName","toggleProperty","preventWithProperty","handler","e","Boolean","stopImmediatePropagation","proxyProperty","object","propertyName","sourceObject","copyFirst","set","proxyEvent","dispatchEvent","Event","dispatchEventAsync","type","Promise","resolve","then","getAudioFromVideo","video","audio","Audio","crossOrigin","src","currentSrc","setTime","time","rememberOnly","lastTimeupdateEvent","Date","ಠevent","currentTime","lastRequests","requestIndex","isPlayerEnded","player","driver","duration","update","timeDiff","readyState","HAVE_FUTURE_DATA","hasAudio","playbackRate","networkState","NETWORK_IDLE","buffered","load","ended","ಠ","webkitDisplayingFullscreen","ಠplay","paused","updater","HAVE_ENOUGH_DATA","forceEvents","ಠpause","addPlayer","bind","muted","wasEmpty","indexOf","overloadAPI","enableInlineVideo","onlyWhitelisted","isWhitelisted","classList","autoplay","navigator","platform","Symbol","test","userAgent","document","head","style","grid","198","index","description","Math","random","199"],"mappings":"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","file":"bulbs-cinemagraph.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _register = __webpack_require__(2);\n\t\n\tvar _util = __webpack_require__(176);\n\t\n\tvar _iphoneInlineVideo = __webpack_require__(197);\n\t\n\tvar iphoneInlineVideo = _interopRequireWildcard(_iphoneInlineVideo);\n\t\n\t__webpack_require__(199);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }\n\t\n\t// We have to do this little dance to properly subclass elements in Safari\n\tfunction BulbsHTMLVideoElement() {}\n\tBulbsHTMLVideoElement.prototype = HTMLVideoElement.prototype;\n\t\n\tvar BulbsCinemagraph = function (_BulbsHTMLVideoElemen) {\n\t  _inherits(BulbsCinemagraph, _BulbsHTMLVideoElemen);\n\t\n\t  function BulbsCinemagraph() {\n\t    _classCallCheck(this, BulbsCinemagraph);\n\t\n\t    return _possibleConstructorReturn(this, _BulbsHTMLVideoElemen.apply(this, arguments));\n\t  }\n\t\n\t  BulbsCinemagraph.prototype.createdCallback = function createdCallback() {\n\t    var _this2 = this;\n\t\n\t    if (!this.hasAttribute('cinemagraph-duration')) {\n\t      console.warn('is=\"bulbs-cinemagraph\" elements should have a [cinemagraph-duration] attribute set');\n\t    }\n\t\n\t    // makeVideoPlayableInline is dumb and goes just a little bit too far in the\n\t    // video, this results in a quick flash of a black frame in the loop. If we\n\t    // override the duration we can get the loop to loop properly.\n\t    // For now, this must be determined by hand.\n\t    Object.defineProperty(this, 'duration', {\n\t      get: function get() {\n\t        return parseFloat(this.getAttribute('cinemagraph-duration')) || 0;\n\t      }\n\t    });\n\t\n\t    this.setAttribute('loop', true);\n\t    this.setAttribute('webkit-playsinline', true);\n\t\n\t    this.addEventListener('enterviewport', function () {\n\t      return _this2.play();\n\t    });\n\t    this.addEventListener('exitviewport', function () {\n\t      return _this2.pause();\n\t    });\n\t  };\n\t\n\t  BulbsCinemagraph.prototype.attachedCallback = function attachedCallback() {\n\t    iphoneInlineVideo.default(this, /* hasAudio */false);\n\t    _util.InViewMonitor.add(this);\n\t  };\n\t\n\t  BulbsCinemagraph.prototype.detachedCallback = function detachedCallback() {\n\t    _util.InViewMonitor.remove(this);\n\t  };\n\t\n\t  return BulbsCinemagraph;\n\t}(BulbsHTMLVideoElement);\n\t\n\tBulbsCinemagraph.extends = 'video';\n\t\n\t(0, _register.registerElement)('bulbs-cinemagraph', BulbsCinemagraph);\n\n/***/ },\n\n/***/ 197:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*! npm.im/iphone-inline-video */\n\t'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar Symbol = _interopDefault(__webpack_require__(198));\n\t\n\tfunction Intervalometer(cb) {\n\t\tvar rafId;\n\t\tvar previousLoopTime;\n\t\tfunction loop(now) {\n\t\t\t// must be requested before cb() because that might call .stop()\n\t\t\trafId = requestAnimationFrame(loop);\n\t\t\tcb(now - (previousLoopTime || now)); // ms since last call. 0 on start()\n\t\t\tpreviousLoopTime = now;\n\t\t}\n\t\tthis.start = function () {\n\t\t\tif (!rafId) { // prevent double starts\n\t\t\t\tloop(0);\n\t\t\t}\n\t\t};\n\t\tthis.stop = function () {\n\t\t\tcancelAnimationFrame(rafId);\n\t\t\trafId = null;\n\t\t\tpreviousLoopTime = 0;\n\t\t};\n\t}\n\t\n\tfunction preventEvent(element, eventName, toggleProperty, preventWithProperty) {\n\t\tfunction handler(e) {\n\t\t\tif (Boolean(element[toggleProperty]) === Boolean(preventWithProperty)) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t// console.log(eventName, 'prevented on', element);\n\t\t\t}\n\t\t\tdelete element[toggleProperty];\n\t\t}\n\t\telement.addEventListener(eventName, handler, false);\n\t\n\t\t// Return handler to allow to disable the prevention. Usage:\n\t\t// const preventionHandler = preventEvent(el, 'click');\n\t\t// el.removeEventHandler('click', preventionHandler);\n\t\treturn handler;\n\t}\n\t\n\tfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n\t\tfunction get() {\n\t\t\treturn sourceObject[propertyName];\n\t\t}\n\t\tfunction set(value) {\n\t\t\tsourceObject[propertyName] = value;\n\t\t}\n\t\n\t\tif (copyFirst) {\n\t\t\tset(object[propertyName]);\n\t\t}\n\t\n\t\tObject.defineProperty(object, propertyName, {get: get, set: set});\n\t}\n\t\n\tfunction proxyEvent(object, eventName, sourceObject) {\n\t\tsourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });\n\t}\n\t\n\tfunction dispatchEventAsync(element, type) {\n\t\tPromise.resolve().then(function () {\n\t\t\telement.dispatchEvent(new Event(type));\n\t\t});\n\t}\n\t\n\t// iOS 10 adds support for native inline playback + silent autoplay\n\t// Also adds unprefixed css-grid. This check essentially excludes\n\tvar isWhitelisted = /iPhone|iPod/i.test(navigator.userAgent) && document.head.style.grid === undefined;\n\t\n\tvar ಠ = Symbol();\n\tvar ಠevent = Symbol();\n\tvar ಠplay = Symbol('nativeplay');\n\tvar ಠpause = Symbol('nativepause');\n\t\n\t/**\n\t * UTILS\n\t */\n\t\n\tfunction getAudioFromVideo(video) {\n\t\tvar audio = new Audio();\n\t\tproxyEvent(video, 'play', audio);\n\t\tproxyEvent(video, 'playing', audio);\n\t\tproxyEvent(video, 'pause', audio);\n\t\taudio.crossOrigin = video.crossOrigin;\n\t\n\t\t// 'data:' causes audio.networkState > 0\n\t\t// which then allows to keep <audio> in a resumable playing state\n\t\t// i.e. once you set a real src it will keep playing if it was if .play() was called\n\t\taudio.src = video.src || video.currentSrc || 'data:';\n\t\n\t\t// if (audio.src === 'data:') {\n\t\t//   TODO: wait for video to be selected\n\t\t// }\n\t\treturn audio;\n\t}\n\t\n\tvar lastRequests = [];\n\tvar requestIndex = 0;\n\tvar lastTimeupdateEvent;\n\t\n\tfunction setTime(video, time, rememberOnly) {\n\t\t// allow one timeupdate event every 200+ ms\n\t\tif ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n\t\t\tvideo[ಠevent] = true;\n\t\t\tlastTimeupdateEvent = Date.now();\n\t\t}\n\t\tif (!rememberOnly) {\n\t\t\tvideo.currentTime = time;\n\t\t}\n\t\tlastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n\t}\n\t\n\tfunction isPlayerEnded(player) {\n\t\treturn player.driver.currentTime >= player.video.duration;\n\t}\n\t\n\tfunction update(timeDiff) {\n\t\tvar player = this;\n\t\t// console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\t\tif (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n\t\t\tif (!player.hasAudio) {\n\t\t\t\tplayer.driver.currentTime = player.video.currentTime + (timeDiff * player.video.playbackRate) / 1000;\n\t\t\t\tif (player.video.loop && isPlayerEnded(player)) {\n\t\t\t\t\tplayer.driver.currentTime = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetTime(player.video, player.driver.currentTime);\n\t\t} else if (player.video.networkState === player.video.NETWORK_IDLE && !player.video.buffered.length) {\n\t\t\t// this should happen when the source is available but:\n\t\t\t// - it's potentially playing (.paused === false)\n\t\t\t// - it's not ready to play\n\t\t\t// - it's not loading\n\t\t\t// If it hasAudio, that will be loaded in the 'emptied' handler below\n\t\t\tplayer.video.load();\n\t\t\t// console.log('Will load');\n\t\t}\n\t\n\t\t// console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\t\n\t\tif (player.video.ended) {\n\t\t\tdelete player.video[ಠevent]; // allow timeupdate event\n\t\t\tplayer.video.pause(true);\n\t\t}\n\t}\n\t\n\t/**\n\t * METHODS\n\t */\n\t\n\tfunction play() {\n\t\t// console.log('play');\n\t\tvar video = this;\n\t\tvar player = video[ಠ];\n\t\n\t\t// if it's fullscreen, use the native player\n\t\tif (video.webkitDisplayingFullscreen) {\n\t\t\tvideo[ಠplay]();\n\t\t\treturn;\n\t\t}\n\t\n\t\tif (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n\t\t\t// console.log('src changed on play', video.src);\n\t\t\tsetTime(video, 0, true);\n\t\t\tplayer.driver.src = video.src;\n\t\t}\n\t\n\t\tif (!video.paused) {\n\t\t\treturn;\n\t\t}\n\t\tplayer.paused = false;\n\t\n\t\tif (!video.buffered.length) {\n\t\t\t// .load() causes the emptied event\n\t\t\t// the alternative is .play()+.pause() but that triggers play/pause events, even worse\n\t\t\t// possibly the alternative is preventing this event only once\n\t\t\tvideo.load();\n\t\t}\n\t\n\t\tplayer.driver.play();\n\t\tplayer.updater.start();\n\t\n\t\tif (!player.hasAudio) {\n\t\t\tdispatchEventAsync(video, 'play');\n\t\t\tif (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n\t\t\t\t// console.log('onplay');\n\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t}\n\t\t}\n\t}\n\tfunction pause(forceEvents) {\n\t\t// console.log('pause');\n\t\tvar video = this;\n\t\tvar player = video[ಠ];\n\t\n\t\tplayer.driver.pause();\n\t\tplayer.updater.stop();\n\t\n\t\t// if it's fullscreen, the developer the native player.pause()\n\t\t// This is at the end of pause() because it also\n\t\t// needs to make sure that the simulation is paused\n\t\tif (video.webkitDisplayingFullscreen) {\n\t\t\tvideo[ಠpause]();\n\t\t}\n\t\n\t\tif (player.paused && !forceEvents) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tplayer.paused = true;\n\t\tif (!player.hasAudio) {\n\t\t\tdispatchEventAsync(video, 'pause');\n\t\t}\n\t\tif (video.ended) {\n\t\t\tvideo[ಠevent] = true;\n\t\t\tdispatchEventAsync(video, 'ended');\n\t\t}\n\t}\n\t\n\t/**\n\t * SETUP\n\t */\n\t\n\tfunction addPlayer(video, hasAudio) {\n\t\tvar player = video[ಠ] = {};\n\t\tplayer.paused = true; // track whether 'pause' events have been fired\n\t\tplayer.hasAudio = hasAudio;\n\t\tplayer.video = video;\n\t\tplayer.updater = new Intervalometer(update.bind(player));\n\t\n\t\tif (hasAudio) {\n\t\t\tplayer.driver = getAudioFromVideo(video);\n\t\t} else {\n\t\t\tvideo.addEventListener('canplay', function () {\n\t\t\t\tif (!video.paused) {\n\t\t\t\t\t// console.log('oncanplay');\n\t\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t\t}\n\t\t\t});\n\t\t\tplayer.driver = {\n\t\t\t\tsrc: video.src || video.currentSrc || 'data:',\n\t\t\t\tmuted: true,\n\t\t\t\tpaused: true,\n\t\t\t\tpause: function () {\n\t\t\t\t\tplayer.driver.paused = true;\n\t\t\t\t},\n\t\t\t\tplay: function () {\n\t\t\t\t\tplayer.driver.paused = false;\n\t\t\t\t\t// media automatically goes to 0 if .play() is called when it's done\n\t\t\t\t\tif (isPlayerEnded(player)) {\n\t\t\t\t\t\tsetTime(video, 0);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tget ended() {\n\t\t\t\t\treturn isPlayerEnded(player);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\t// .load() causes the emptied event\n\t\tvideo.addEventListener('emptied', function () {\n\t\t\t// console.log('driver src is', player.driver.src);\n\t\t\tvar wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\t\t\tif (player.driver.src && player.driver.src !== video.src) {\n\t\t\t\t// console.log('src changed to', video.src);\n\t\t\t\tsetTime(video, 0, true);\n\t\t\t\tplayer.driver.src = video.src;\n\t\t\t\t// playing videos will only keep playing if no src was present when .play()’ed\n\t\t\t\tif (wasEmpty) {\n\t\t\t\t\tplayer.driver.play();\n\t\t\t\t} else {\n\t\t\t\t\tplayer.updater.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t}, false);\n\t\n\t\t// stop programmatic player when OS takes over\n\t\tvideo.addEventListener('webkitbeginfullscreen', function () {\n\t\t\tif (!video.paused) {\n\t\t\t\t// make sure that the <audio> and the syncer/updater are stopped\n\t\t\t\tvideo.pause();\n\t\n\t\t\t\t// play video natively\n\t\t\t\tvideo[ಠplay]();\n\t\t\t} else if (hasAudio && !player.driver.buffered.length) {\n\t\t\t\t// if the first play is native,\n\t\t\t\t// the <audio> needs to be buffered manually\n\t\t\t\t// so when the fullscreen ends, it can be set to the same current time\n\t\t\t\tplayer.driver.load();\n\t\t\t}\n\t\t});\n\t\tif (hasAudio) {\n\t\t\tvideo.addEventListener('webkitendfullscreen', function () {\n\t\t\t\t// sync audio to new video position\n\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t\t// console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n\t\t\t});\n\t\n\t\t\t// allow seeking\n\t\t\tvideo.addEventListener('seeking', function () {\n\t\t\t\tif (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n\t\t\t\t\t// console.log('User-requested seeking');\n\t\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\t\n\tfunction overloadAPI(video) {\n\t\tvar player = video[ಠ];\n\t\tvideo[ಠplay] = video.play;\n\t\tvideo[ಠpause] = video.pause;\n\t\tvideo.play = play;\n\t\tvideo.pause = pause;\n\t\tproxyProperty(video, 'paused', player.driver);\n\t\tproxyProperty(video, 'muted', player.driver, true);\n\t\tproxyProperty(video, 'playbackRate', player.driver, true);\n\t\tproxyProperty(video, 'ended', player.driver);\n\t\tproxyProperty(video, 'loop', player.driver, true);\n\t\tpreventEvent(video, 'seeking');\n\t\tpreventEvent(video, 'seeked');\n\t\tpreventEvent(video, 'timeupdate', ಠevent, false);\n\t\tpreventEvent(video, 'ended', ಠevent, false); // prevent occasional native ended events\n\t}\n\t\n\tfunction enableInlineVideo(video, hasAudio, onlyWhitelisted) {\n\t\tif ( hasAudio === void 0 ) hasAudio = true;\n\t\tif ( onlyWhitelisted === void 0 ) onlyWhitelisted = true;\n\t\n\t\tif ((onlyWhitelisted && !isWhitelisted) || video[ಠ]) {\n\t\t\treturn;\n\t\t}\n\t\taddPlayer(video, hasAudio);\n\t\toverloadAPI(video);\n\t\tvideo.classList.add('IIV');\n\t\tif (!hasAudio && video.autoplay) {\n\t\t\tvideo.play();\n\t\t}\n\t\tif (navigator.platform === 'MacIntel' || navigator.platform === 'Windows') {\n\t\t\tconsole.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n\t\t}\n\t}\n\t\n\tenableInlineVideo.isWhitelisted = isWhitelisted;\n\t\n\tmodule.exports = enableInlineVideo;\n\n/***/ },\n\n/***/ 198:\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar index = typeof Symbol === 'undefined' ? function (description) {\n\t\treturn '@' + (description || '@') + Math.random();\n\t} : Symbol;\n\t\n\tmodule.exports = index;\n\n/***/ },\n\n/***/ 199:\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** bulbs-cinemagraph.js\n **/","import { registerElement } from 'bulbs-elements/register';\nimport { InViewMonitor } from 'bulbs-elements/util';\nimport * as iphoneInlineVideo from 'iphone-inline-video';\nimport './bulbs-cinemagraph.scss';\n\n// We have to do this little dance to properly subclass elements in Safari\nfunction BulbsHTMLVideoElement () {}\nBulbsHTMLVideoElement.prototype = HTMLVideoElement.prototype;\n\nclass BulbsCinemagraph extends BulbsHTMLVideoElement {\n  createdCallback () {\n    if (!this.hasAttribute('cinemagraph-duration')) {\n      console.warn('is=\"bulbs-cinemagraph\" elements should have a [cinemagraph-duration] attribute set');\n    }\n\n    // makeVideoPlayableInline is dumb and goes just a little bit too far in the\n    // video, this results in a quick flash of a black frame in the loop. If we\n    // override the duration we can get the loop to loop properly.\n    // For now, this must be determined by hand.\n    Object.defineProperty(this, 'duration', {\n      get () {\n        return parseFloat(this.getAttribute('cinemagraph-duration')) || 0;\n      },\n    });\n\n    this.setAttribute('loop', true);\n    this.setAttribute('webkit-playsinline', true);\n\n    this.addEventListener('enterviewport', () => this.play());\n    this.addEventListener('exitviewport', () => this.pause());\n  }\n\n  attachedCallback () {\n    iphoneInlineVideo.default(this, /* hasAudio */ false);\n    InViewMonitor.add(this);\n  }\n\n  detachedCallback () {\n    InViewMonitor.remove(this);\n  }\n}\n\nBulbsCinemagraph.extends = 'video';\n\nregisterElement('bulbs-cinemagraph', BulbsCinemagraph);\n\n\n\n/** WEBPACK FOOTER **\n ** ./elements/bulbs-cinemagraph/bulbs-cinemagraph.js\n **/","/*! npm.im/iphone-inline-video */\n'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar Symbol = _interopDefault(require('poor-mans-symbol'));\n\nfunction Intervalometer(cb) {\n\tvar rafId;\n\tvar previousLoopTime;\n\tfunction loop(now) {\n\t\t// must be requested before cb() because that might call .stop()\n\t\trafId = requestAnimationFrame(loop);\n\t\tcb(now - (previousLoopTime || now)); // ms since last call. 0 on start()\n\t\tpreviousLoopTime = now;\n\t}\n\tthis.start = function () {\n\t\tif (!rafId) { // prevent double starts\n\t\t\tloop(0);\n\t\t}\n\t};\n\tthis.stop = function () {\n\t\tcancelAnimationFrame(rafId);\n\t\trafId = null;\n\t\tpreviousLoopTime = 0;\n\t};\n}\n\nfunction preventEvent(element, eventName, toggleProperty, preventWithProperty) {\n\tfunction handler(e) {\n\t\tif (Boolean(element[toggleProperty]) === Boolean(preventWithProperty)) {\n\t\t\te.stopImmediatePropagation();\n\t\t\t// console.log(eventName, 'prevented on', element);\n\t\t}\n\t\tdelete element[toggleProperty];\n\t}\n\telement.addEventListener(eventName, handler, false);\n\n\t// Return handler to allow to disable the prevention. Usage:\n\t// const preventionHandler = preventEvent(el, 'click');\n\t// el.removeEventHandler('click', preventionHandler);\n\treturn handler;\n}\n\nfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n\tfunction get() {\n\t\treturn sourceObject[propertyName];\n\t}\n\tfunction set(value) {\n\t\tsourceObject[propertyName] = value;\n\t}\n\n\tif (copyFirst) {\n\t\tset(object[propertyName]);\n\t}\n\n\tObject.defineProperty(object, propertyName, {get: get, set: set});\n}\n\nfunction proxyEvent(object, eventName, sourceObject) {\n\tsourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });\n}\n\nfunction dispatchEventAsync(element, type) {\n\tPromise.resolve().then(function () {\n\t\telement.dispatchEvent(new Event(type));\n\t});\n}\n\n// iOS 10 adds support for native inline playback + silent autoplay\n// Also adds unprefixed css-grid. This check essentially excludes\nvar isWhitelisted = /iPhone|iPod/i.test(navigator.userAgent) && document.head.style.grid === undefined;\n\nvar ಠ = Symbol();\nvar ಠevent = Symbol();\nvar ಠplay = Symbol('nativeplay');\nvar ಠpause = Symbol('nativepause');\n\n/**\n * UTILS\n */\n\nfunction getAudioFromVideo(video) {\n\tvar audio = new Audio();\n\tproxyEvent(video, 'play', audio);\n\tproxyEvent(video, 'playing', audio);\n\tproxyEvent(video, 'pause', audio);\n\taudio.crossOrigin = video.crossOrigin;\n\n\t// 'data:' causes audio.networkState > 0\n\t// which then allows to keep <audio> in a resumable playing state\n\t// i.e. once you set a real src it will keep playing if it was if .play() was called\n\taudio.src = video.src || video.currentSrc || 'data:';\n\n\t// if (audio.src === 'data:') {\n\t//   TODO: wait for video to be selected\n\t// }\n\treturn audio;\n}\n\nvar lastRequests = [];\nvar requestIndex = 0;\nvar lastTimeupdateEvent;\n\nfunction setTime(video, time, rememberOnly) {\n\t// allow one timeupdate event every 200+ ms\n\tif ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n\t\tvideo[ಠevent] = true;\n\t\tlastTimeupdateEvent = Date.now();\n\t}\n\tif (!rememberOnly) {\n\t\tvideo.currentTime = time;\n\t}\n\tlastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n}\n\nfunction isPlayerEnded(player) {\n\treturn player.driver.currentTime >= player.video.duration;\n}\n\nfunction update(timeDiff) {\n\tvar player = this;\n\t// console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\tif (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n\t\tif (!player.hasAudio) {\n\t\t\tplayer.driver.currentTime = player.video.currentTime + (timeDiff * player.video.playbackRate) / 1000;\n\t\t\tif (player.video.loop && isPlayerEnded(player)) {\n\t\t\t\tplayer.driver.currentTime = 0;\n\t\t\t}\n\t\t}\n\t\tsetTime(player.video, player.driver.currentTime);\n\t} else if (player.video.networkState === player.video.NETWORK_IDLE && !player.video.buffered.length) {\n\t\t// this should happen when the source is available but:\n\t\t// - it's potentially playing (.paused === false)\n\t\t// - it's not ready to play\n\t\t// - it's not loading\n\t\t// If it hasAudio, that will be loaded in the 'emptied' handler below\n\t\tplayer.video.load();\n\t\t// console.log('Will load');\n\t}\n\n\t// console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\n\tif (player.video.ended) {\n\t\tdelete player.video[ಠevent]; // allow timeupdate event\n\t\tplayer.video.pause(true);\n\t}\n}\n\n/**\n * METHODS\n */\n\nfunction play() {\n\t// console.log('play');\n\tvar video = this;\n\tvar player = video[ಠ];\n\n\t// if it's fullscreen, use the native player\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[ಠplay]();\n\t\treturn;\n\t}\n\n\tif (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n\t\t// console.log('src changed on play', video.src);\n\t\tsetTime(video, 0, true);\n\t\tplayer.driver.src = video.src;\n\t}\n\n\tif (!video.paused) {\n\t\treturn;\n\t}\n\tplayer.paused = false;\n\n\tif (!video.buffered.length) {\n\t\t// .load() causes the emptied event\n\t\t// the alternative is .play()+.pause() but that triggers play/pause events, even worse\n\t\t// possibly the alternative is preventing this event only once\n\t\tvideo.load();\n\t}\n\n\tplayer.driver.play();\n\tplayer.updater.start();\n\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'play');\n\t\tif (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n\t\t\t// console.log('onplay');\n\t\t\tdispatchEventAsync(video, 'playing');\n\t\t}\n\t}\n}\nfunction pause(forceEvents) {\n\t// console.log('pause');\n\tvar video = this;\n\tvar player = video[ಠ];\n\n\tplayer.driver.pause();\n\tplayer.updater.stop();\n\n\t// if it's fullscreen, the developer the native player.pause()\n\t// This is at the end of pause() because it also\n\t// needs to make sure that the simulation is paused\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[ಠpause]();\n\t}\n\n\tif (player.paused && !forceEvents) {\n\t\treturn;\n\t}\n\n\tplayer.paused = true;\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'pause');\n\t}\n\tif (video.ended) {\n\t\tvideo[ಠevent] = true;\n\t\tdispatchEventAsync(video, 'ended');\n\t}\n}\n\n/**\n * SETUP\n */\n\nfunction addPlayer(video, hasAudio) {\n\tvar player = video[ಠ] = {};\n\tplayer.paused = true; // track whether 'pause' events have been fired\n\tplayer.hasAudio = hasAudio;\n\tplayer.video = video;\n\tplayer.updater = new Intervalometer(update.bind(player));\n\n\tif (hasAudio) {\n\t\tplayer.driver = getAudioFromVideo(video);\n\t} else {\n\t\tvideo.addEventListener('canplay', function () {\n\t\t\tif (!video.paused) {\n\t\t\t\t// console.log('oncanplay');\n\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t}\n\t\t});\n\t\tplayer.driver = {\n\t\t\tsrc: video.src || video.currentSrc || 'data:',\n\t\t\tmuted: true,\n\t\t\tpaused: true,\n\t\t\tpause: function () {\n\t\t\t\tplayer.driver.paused = true;\n\t\t\t},\n\t\t\tplay: function () {\n\t\t\t\tplayer.driver.paused = false;\n\t\t\t\t// media automatically goes to 0 if .play() is called when it's done\n\t\t\t\tif (isPlayerEnded(player)) {\n\t\t\t\t\tsetTime(video, 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\tget ended() {\n\t\t\t\treturn isPlayerEnded(player);\n\t\t\t}\n\t\t};\n\t}\n\n\t// .load() causes the emptied event\n\tvideo.addEventListener('emptied', function () {\n\t\t// console.log('driver src is', player.driver.src);\n\t\tvar wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\t\tif (player.driver.src && player.driver.src !== video.src) {\n\t\t\t// console.log('src changed to', video.src);\n\t\t\tsetTime(video, 0, true);\n\t\t\tplayer.driver.src = video.src;\n\t\t\t// playing videos will only keep playing if no src was present when .play()’ed\n\t\t\tif (wasEmpty) {\n\t\t\t\tplayer.driver.play();\n\t\t\t} else {\n\t\t\t\tplayer.updater.stop();\n\t\t\t}\n\t\t}\n\t}, false);\n\n\t// stop programmatic player when OS takes over\n\tvideo.addEventListener('webkitbeginfullscreen', function () {\n\t\tif (!video.paused) {\n\t\t\t// make sure that the <audio> and the syncer/updater are stopped\n\t\t\tvideo.pause();\n\n\t\t\t// play video natively\n\t\t\tvideo[ಠplay]();\n\t\t} else if (hasAudio && !player.driver.buffered.length) {\n\t\t\t// if the first play is native,\n\t\t\t// the <audio> needs to be buffered manually\n\t\t\t// so when the fullscreen ends, it can be set to the same current time\n\t\t\tplayer.driver.load();\n\t\t}\n\t});\n\tif (hasAudio) {\n\t\tvideo.addEventListener('webkitendfullscreen', function () {\n\t\t\t// sync audio to new video position\n\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t// console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n\t\t});\n\n\t\t// allow seeking\n\t\tvideo.addEventListener('seeking', function () {\n\t\t\tif (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n\t\t\t\t// console.log('User-requested seeking');\n\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction overloadAPI(video) {\n\tvar player = video[ಠ];\n\tvideo[ಠplay] = video.play;\n\tvideo[ಠpause] = video.pause;\n\tvideo.play = play;\n\tvideo.pause = pause;\n\tproxyProperty(video, 'paused', player.driver);\n\tproxyProperty(video, 'muted', player.driver, true);\n\tproxyProperty(video, 'playbackRate', player.driver, true);\n\tproxyProperty(video, 'ended', player.driver);\n\tproxyProperty(video, 'loop', player.driver, true);\n\tpreventEvent(video, 'seeking');\n\tpreventEvent(video, 'seeked');\n\tpreventEvent(video, 'timeupdate', ಠevent, false);\n\tpreventEvent(video, 'ended', ಠevent, false); // prevent occasional native ended events\n}\n\nfunction enableInlineVideo(video, hasAudio, onlyWhitelisted) {\n\tif ( hasAudio === void 0 ) hasAudio = true;\n\tif ( onlyWhitelisted === void 0 ) onlyWhitelisted = true;\n\n\tif ((onlyWhitelisted && !isWhitelisted) || video[ಠ]) {\n\t\treturn;\n\t}\n\taddPlayer(video, hasAudio);\n\toverloadAPI(video);\n\tvideo.classList.add('IIV');\n\tif (!hasAudio && video.autoplay) {\n\t\tvideo.play();\n\t}\n\tif (navigator.platform === 'MacIntel' || navigator.platform === 'Windows') {\n\t\tconsole.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n\t}\n}\n\nenableInlineVideo.isWhitelisted = isWhitelisted;\n\nmodule.exports = enableInlineVideo;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/iphone-inline-video/dist/iphone-inline-video.common-js.js\n ** module id = 197\n ** module chunks = 1\n **/","'use strict';\n\nvar index = typeof Symbol === 'undefined' ? function (description) {\n\treturn '@' + (description || '@') + Math.random();\n} : Symbol;\n\nmodule.exports = index;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/poor-mans-symbol/dist/poor-mans-symbol.common-js.js\n ** module id = 198\n ** module chunks = 1\n **/"],"sourceRoot":""}